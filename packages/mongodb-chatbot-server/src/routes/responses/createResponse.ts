import { z } from "zod";
import { SomeExpressRequest } from "../../middleware/validateRequestSchema";

export const CreateResponseRequestBodySchema = z.object({
  model: z
    .string()
    .refine(
      (model) => model === "mongodb-chat-latest",
      "Model must be mongodb-chat-latest"
    ),
  instructions: z.string().optional(),
  input: z.union([
    z
      .string()
      .refine((input) => input.length > 0, "Input must be a non-empty string"),
    z
      .array(
        z.union([
          z.object({
            type: z.literal("message").optional(),
            role: z.enum(["user", "assistant", "system"]),
            content: z.string(),
          }),
          // function tool call
          z.object({
            type: z.literal("function_call"),
            id: z
              .string()
              .optional()
              .describe("Unique ID of the function tool call"),
            name: z.string().describe("Name of the function tool to call"),
            arguments: z
              .string()
              .describe(
                "JSON string of arguments passed to the function tool call"
              ),
            status: z.enum(["in_progress", "completed", "incomplete"]),
          }),
          // function tool call output
          z.object({
            type: z.literal("function_call_output"),
            id: z
              .string()
              .optional()
              .describe("The unique ID of the function tool call output"),
            call_id: z
              .string()
              .describe(
                "Unique ID of the function tool call generated by the model"
              ),
            output: z
              .string()
              .describe("JSON string of the function tool call"),
            status: z.enum(["in_progress", "completed", "incomplete"]),
          }),
        ])
      )
      .refine((input) => input.length > 0, "Input must be a non-empty array"),
  ]),
  max_output_tokens: z.number().min(0).max(4000).optional().default(1000),
  metadata: z
    .record(z.string(), z.string().max(512))
    .optional()
    .refine(
      (metadata) => Object.keys(metadata ?? {}).length <= 16,
      "Too many metadata fields. Max 16."
    ),
  previous_response_id: z
    .string()
    .optional()
    .describe("The unique ID of the previous response to the model."),
  store: z
    .boolean()
    .optional()
    .describe("Whether to store the response in the conversation.")
    .default(true),
  stream: z.literal(true, {
    errorMap: () => ({ message: "'stream' must be true" }),
  }),
  temperature: z
    .union([
      z.literal(0, {
        errorMap: () => ({ message: "Temperature must be 0 or unset" }),
      }),
      z.undefined(),
    ])
    .optional()
    .describe("Temperature for the model. Defaults to 0.")
    .default(0),
  tool_choice: z
    .union([
      z.enum(["none", "only", "auto"]),
      z
        .object({
          name: z.string(),
          type: z.literal("function"),
        })
        .describe("Function tool choice"),
    ])
    .optional()
    .describe("Tool choice for the model. Defaults to 'auto'.")
    .default("auto"),
  tools: z
    .array(
      z.object({
        name: z.string(),
        description: z.string().optional(),
        parameters: z
          .record(z.string(), z.unknown())
          .describe(
            "A JSON schema object describing the parameters of the function."
          ),
      })
    )
    .optional()
    .describe("Tools for the model to use."),

  user: z.string().optional().describe("The user ID of the user."),
});

export const CreateResponseRequest = SomeExpressRequest.merge(
  z.object({
    headers: z.object({
      "req-id": z.string(),
    }),
    body: CreateResponseRequestBodySchema,
  })
);

export type CreateResponseRequest = z.infer<typeof CreateResponseRequest>;
